
Let f(i) be the minimum time you can save starting from day i. 

Your optinos are to skip day i, or skip day i and day i + 1, But here we cannot say the answer is f(i + 2) because f(i + 2) includes the case where day i+2 was skipped.
We can't use optimal substructure like this as the problems won't be independent.

This forces us to use a new dimension.

f(i, WORK) represent the time required starting from day i, if you work on day i. 
Now, we realise we can use optimal substructure.

f(i, WORK) = time[i] + min{f(i + 1, WORK), f(i + 1, NO WORK)}

f(i, NO WORK) = min{f(i + 1, WORK), f(i + 2, WORK)} depending on whether you skip one day or two. 

This allows us to safely use the solutions to smaller problems without worrying about whether the structure of the overall problem is intact.

The answer = min{f(1, WORK), f(1, NO WORK)}

--------------------------------------------------------

int main()
{
    int no_of_days;
    scanf("%d", &no_of_days);

    vector <int> time(no_of_days + 5, 0);
    for(int i = 1; i <= no_of_days; i++)
        scanf("%d", &time[i]);

    const int WORK = 0, NO_WORK = 1;
    int minimum_time_starting[no_of_days + 5][2];


    for(int i = no_of_days; i >= 1; i--)
    {
        if(i == no_of_days || i == no_of_days - 1)
        {
            minimum_time_starting[i][WORK] = time[i];
            minimum_time_starting[i][NO_WORK] = 0;
            continue;
        }

        minimum_time_starting[i][NO_WORK] = min(minimum_time_starting[i + 1][WORK], minimum_time_starting[i + 2][WORK]);

        minimum_time_starting[i][WORK] = time[i] + min(minimum_time_starting[i + 1][WORK], minimum_time_starting[i + 1][NO_WORK]);
    }

    int total_time = min(minimum_time_starting[1][WORK], minimum_time_starting[1][NO_WORK]);
    printf("%d\n", total_time);

    return 0;
}
